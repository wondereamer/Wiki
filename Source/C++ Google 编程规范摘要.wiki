%template header
%title C++ Google 编程规范摘要
%toc 
[[index|主页]]
= C++ Google 编程规范摘要 =
== 好的编程建议 ==
# 不要将嵌套类定义为共有，除非它们是接口的一部分。
# 使用静态成员函数或名字空间内的非成员函数, 尽量不要用裸的全局函数。
# 提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好。
# 通常，构造函数应仅用于设置成员变量的初始值。任何复杂的初始化操作都应该放到明确的 Init() 方法中。
    * 构造函数中很难上报错误, 不能使用异常。
    * 操作失败会造成对象初始化失败，进入不确定状态。
    * 如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使 当前没有子类化实现, 将来仍是隐患.
    * 如果有人创建该类型的全局变量(虽然违背了上节提到的规则), 构造函数将先main() 一 步被调用,
      <br/>
      有可能破坏构造函数中暗含的假设条件. 例如, gflags 尚未初始化。
# 如果一个类定义了若干成员变量又没有其它构造函数, 必须定义一个默认构造函数。
  <br/>
  否则编译器将自动生产一个很糟糕的默认构造函数。
# 对单个参数的构造函数使用C++ 关键字explicit。
  <br/>
 在极少数情况下, 拷贝构造函数可以不声明成explicit。
  <br/>
 作为其它类的透明包装器的 类也是特例之一。
# 仅在必要时才定义拷贝构造函数和重载赋值运算符。否则应使用 DISAL-LOW_COPY_AND_ASSIGN 禁用它们。
  <br/>
  优先考虑定义拷贝方法，比如CopyFrom() 或Clone()，而不是拷贝构造函数，因为这类方法不能被隐式调用。
  <br/>
  大多数拷贝构造函数和赋值运算符重载都不需要。大多数情况下，指针或引用和值拷贝一样能解决问题，性能还更好。
  <br/>
# 仅当只有数据时使用struct, 其它一概使用class。除了构造函数, 析构函数, 
  <br/>
  Initialize(), Reset(), Validate() 外, 不能提供其它功能的函数。
# 使用组合比继承更合理，如果要继承定义为public继承。
  <br/>
  实现继承, 由于子类的实现代码散布在父类和子类间之间, 要理解其实现变得更加困难
# 真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有
  <br/>
  一个基类是非抽象类; 其它基类都是以Interface 为后缀的纯接口类。
# 接口是指满足特定条件的类, 这些类以Interface 为后缀(不强制)。
  <br/>
  接口的定义:
    * 只有纯虚函数(“=0”) 和静态函数(除了下文提到的析构函数).
    * 没有非静态数据成员.
    * 没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为protected.
    * 如果它是一个子类, 也只能从满足上述条件并以Interface 为后缀的类继承
# 倾向编写简短, 凝练的函数。
# 如果确实需要使用智能指针的话, scoped_ptr完全可以胜任。
  <br/>
  你应该只在非常特定的情况。下使用std::tr1::shared_ptr, 例如STL 容器中的对象。任何情况下都不要使用auto_ptr
  <br/>
  倾向于设计对象隶属明确的代码, 最明确的对象隶属是根本不使用指针, 直接将对象 作为一个作用域或局部变量使用
# 仅当代码阅读者查看调用点时能一眼就能理解所做操作，而无须先弄清楚所调用的是哪个重载 函数时，才使用使用重载函数（含构造函数）
# 如果你想重载一个函数, 考虑让函数名包含参数信息, 例如, 使用AppendString(), AppendInt() 而不是Append().
# 不推荐使用缺省函数，大家通常都是通过查看别人的代码来推断如何使用API。用了缺省参数的代码更难维护。
# 通常友元应该定义在同一文件内, 避免代码读者跑到其它文件查找使用该私有成员的类。
  <br/>
  友元扩大了(但没有打破) 类的封装边界. 某些情况下, 相对于将类成员声明为public, 使用友元
  <br/>
  是更好的选择, 尤其是如果你只允许另一个类访问该类的私有成员时。
# 不使用C++异常。
# 除单元测试外, 不要使用RTTI。如果你需要在运行期间确定一个对象的类型,
  <br/>
  这通常说明你需要考虑重新设计你的类。typeid, dynamic_cast。
# 对于迭代器和其他模板对象使用前缀形式(++i) 的自增, 自减运算符。
# 我们强烈建议你在任何可能的情况下都要使用const。缺点：
  <br/>
  const是入侵性的: 如果你向一个函数传入const 变量, 函数原型声明中也必须对应
  <br/>
  const参数(否则变量需要const_cast 类型转换), 在调用库函数时显得尤其麻烦。
# 尽量不使用宏，尽量不再.h文件中使用宏。
# 尽可能用sizeof(varname) 代替sizeof(type)。因为当代码中变量类型改变时会自动更新。
# 在循环作用域外面声明某些变量要高效的多:
{{{class="brush: c++" 
Foo f; // 构造函数和?构函数只调用1 次
for (int i = 0; i < 1000000; ++i) {
f.DoSomething(i);
}
}}}
# 只有当函数只有10 行甚至更少时才将其定义为内联函数，函数中最好不要包括循环和switch语句。



== 约定, 这是我们要尽量遵循的编程风格, 便于交流。 ==
=== 命名和使用风格 ===
# 只使用空格, 每次缩进使用一个tab。（注意，要让编辑器自动把tab转化为空格）
# 把数据成员声明为private，并根据需要提供存取函数。
# 整数用0, 实数用0.0, 指针用NULL, 字符(串) 用'\0'。
# 函数参数顺序：（输入参数， 输出参数），其中输入参数：const引用类型。输出参数：指针类型。
  要远胜过要用注释解释的含糊不清的名字
# 类型和变量应该是名词, 尽量不用缩写。
# 注释固然很重要, 但最好的代码本身应该是自文档化. 有意义的类型名和变量名, 
  <br/>
# 文件名要全部小写, 可以包含下划线(_) 或连字符(-)。
# 类型名称的每个单词首字母均大写, 不包含下划线: MyExcitingClass。
  <br/>
  所有类型命名——类, 结构体, 类型定义(typedef), 枚举——均使用相同约定。
# 变量名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 结构体的成员变量不用接下划线。
  <br/>
  建议全局变量可加g_前缀。 在常量名称前加k: kDaysInAWeek
# 常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配:
  <br/>
  MyExcitingFunction(), MyExcitingMethod(), 
  <br/>
  my_exciting_member_variable(), set_my_exciting_member_variable().
# 如果函数发生错误后会崩溃，你应该在函数名后追加OrDie 。这只适用于可发布代码中的函数，
  <br/>
  以及很有可能在常规操作过程中发生的异常。
# 枚举名 
{{{class="brush: c++" 
enum UrlTableErrors {
    kOK = 0,
    kErrorOutOfMemory,
    kErrorMalformedInput,
};
}}}
# 宏名格式: MY_MACRO_THAT_SCARES_SMALL_CHILDREN
# 如果你命名的实体与已有C/C++ 实体相似, 可参考现有命名策略。
  <br/>
  如：sparse_hash_map:    STL 相似实体; 参照STL 命名约定。
  


=== 注释 ===
# 使用// 或/* */, 统一就好.
# 在每一个文件开头加入版权公告, 然后是文件内容描述.
# 通常, .h 文件要对所声明的类的功能和用法作简单说明. .cc 文件通常包含了更多的实现细节
  <br/>
  或算法技巧讨论, 如果你感觉这些实现细节或算法技巧讨论对于理解.h 文件有帮助, 可以该注
  <br/>
  释挪到.h, 并在.cc 中指出文档在.h。
# 每个类的定义都要附带一份注释, 描述类的功能和用法。
# 如果变量可以接受NULL 或-1 等警戒值, 须加以说明。
# 巧妙或复杂的代码段前要加注释。
  <br/>
  比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释。
# NULL, true/false, 1, 2, 3...:向函数传入NULL, 布尔值或整数时, 要注释说明含义, 或使用常量让代码望文知意.
{{{class="brush: c++" 
bool success = CalculateSomething(interesting_value,
                                  10, // Default base value.
                                  false, // Not the first time we’re calling this.
                                  NULL); // No callback.
}}}
# 对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用TODO 注释。
  <br/>
  // TODO(kl@gmail.com): Use a ”*” here for concatenation operator.
  <br/>
  // TODO(Zeke) change this to use relation
# 函数声明处注释描述函数功能; 定义处描述函数实现（如何工作）。
  函数声明处注释的内容:
    * 函数的输入输出.
    * 对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.
    * 如果函数分配了空间, 需要由调用者释放.
    * 参数是否可以为NULL.
    * 是否存在函数使用上的性能隐患.
    * 如果函数是可重入的, 其同步前提是什么?

=== 排版 ===
# 每一行代码字符数不超过80。
# 定义宏，避免多重包含，其中宏名依据所在项目源代码树的全路径 
   {{{class="brush: c++;"
   #ifndef FOO_BAR_BAZ_H_ 
   #define FOO_BAR_BAZ_H_
        ...
   #ifndef FOO_BAR_BAZ_H_
   }}}
# cpp文件中包含头文件的顺序：
    * cpp文件对应的头文件
    * c 系统文件
    * c++ 系统文件
    * 其它第三方库的文件
    * 本项目内的文件
  在保持次分类排序的情况下再按字母顺序排序
# 鼓励在cpp文件中使用匿名空间, 不要再.h文件中使用匿名空间
  {{{class="brush: c++" 
  namespace {
    ...
  } // namespace
  }}}
# 具名空间的使用方式
    * 把除文件包含、类的前置声明、gflags声明和定义以外的整个源文件包含起来
      {{{class="brush: c++" 
        // .h 文件
        namespace mynamespace {
        // 所有声明都置于命名空间中
        // 注意不要使用缩进
        class MyClass {
         public:
                …
            void Foo();
        };
        } // namespace mynamespace
        
        // .cpp 文件
        namespace mynamespace {
        // 函数定义都置于命名空间中
        void MyClass::Foo() {
        …
        }
        } // namespace mynamespace
      }}}
    * 最好不用在名字空间里使用`using`关键字，避免污染名字空间。
    * 在.cc文件(名字空间外), .h文件的函数, 方法或类中, 可以使用`using` 关键字。
    * 允许在.cc 文件(名字空间外)、封装整个.h 文件的具名名字空间内、函数或方法中使用名字空间别名。
      `namespace fbz = ::foo::bar::baz;`
# 类中声明区段顺序为: public, protected, private。每次缩进一个空格。每个区段类声明顺序如下：
    * typedefs 和枚举
    * 常量（static const 数据成员）
    * 构造函数
    * 析构函数
    * 成员函数, 含静态成员函数
    * 数据成员（除了static const 数据成员）
{{{class="brush: c++" 
class MyClass : public OtherClass {
 public: // Note the 1 space indent!
    MyClass(); // Regular 2 space indent.
    explicit MyClass(int var);
    ~MyClass() {}
    void SomeFunction();
    void SomeFunctionThatDoesNothing() {
    }
    void set_some_var(int var) { some_var_ = var; }
    int some_var() const { return some_var_; }
 private:
    bool SomeInternalFunction();
    int some_var_;
    int some_other_var_;
    DISALLOW_COPY_AND_ASSIGN(MyClass);
};

}}}
# 友元声明应当总是放在私有区段，对宏DISALLOW_COPY_AND_ASSIGN 的调用放在private区段的末尾.
# 函数定义，函数调用的风格也类似
{{{class="brush: c++" 
// 返回类型和函数名在同一行, 参数也尽量放在同一行
ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
    DoSomething();
    ...
}

// 如果同一行文本太多, 放不下所有参数:
ReturnType ClassName::ReallyLongFunctionName(Type par_name1,
                                             Type par_name2,
                                             Type par_name3) {
    DoSomething();
    ...
}

// 甚至连第一个参数都放不下:
ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
        Type par_name1, // 4 space indent
        Type par_name2,
        Type par_name3) {
    DoSomething(); // 2 space indent
    ...
}

// 函数声明成const:
ReturnType FunctionName(Type par) const {
    ...
}
}}}
# 
{{{class="brush: c++" 
if (condition) { // no spaces inside parentheses
    ... // 2 space indent.
} else { // The else goes on the same line as the closing brace.
    ...
}

if (x == kFoo) return new Foo();

// case 里面的大括号是否使用取决于自己
switch (var) {
    case 0: { // 2 space indent
        ... // 4 space indent
        break;
    }
    case 1: {
        ...
        break;
    }
    default: {
        assert(false);
    }
}

空循环体应使用{} 或continue, 而不是一个简单的分号.
for (int i = 0; i < kSomeNumber; ++i) {} // Good - empty body.
while (condition) continue; // Good - continue indicates no logic.

if (this_one_thing > this_other_thing &&
    a_third_thing == a_fourth_thing &&
    yet_another && last_one) {
    ...
}

if (lopsided_score) {
#if DISASTER_PENDING // Correct -- Starts at beginning of line
    DropEverything();
#endif
    BackToNormal();
}

namespace {
void foo() { // 正确,名字空间内无需额外缩进
    ...
}
} // namespace

}}}
# 构造函数初始化列表放在同一行或按2个tab(需要转空格)缩进并排几行.
{{{class="brush: c++" 
// When it all fits on one line:
MyClass::MyClass(int var) : some_var_(var), some_other_var_(var + 1) {
    ...
}
或
MyClass::MyClass(int var)
        : some_var_(var), // 2 tab(需要转空格)
          some_other_var_(var + 1) { // lined up
    ...
    DoSomething();
    ...
}
}}}
# 水平留白的使用因地制宜.  永远不要在行尾添加没意义的留白.垂直留白越少越好.
    * 函数体首尾的空行对可读性毫无帮助。
    * if-else 连锁代码段间的空行对可读性可能有所帮助。
