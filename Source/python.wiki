%template header
%title python编程标准
%toc 
[[index|主页]]
 = PEP8 Python 编码规范 =
== 一 代码编排 ==
# 缩进。4个空格的缩进（编辑器都可以完成此功能），不使用Tap，更不能混合使用Tap和空格。
# 每行最大长度79，换行可以使用反斜杠，最好使用圆括号。换行点要在操作符的后边敲回车。
# *类和top-level函数定义之间空两行；类中的方法定义之间空一行；函数内逻辑无关段落之间空一行；其他地方尽量不要再空行。*

== 二 文档编排 ==
# *模块内容的顺序：模块说明和docstring—import—globals&constants—其他定义。其中import部分，又按标准、三方和自己编写顺序依次排放，之间空一行。*
# *不要在一句import中多个库，比如import os, sys不推荐。但是可以 from xx import x1, x2*
# Wildcard imports (from <module> import *) should be avoided. 
== 三 空格的使用 ==
        总体原则，避免不必要的空格。
# 各种右括号前不要加空格。
# 逗号、冒号、分号前不要加空格。
# 函数的左括号前不要加空格。如Func(1)。
# 序列的左括号前不要加空格。如list[2]。
# 操作符左右各加一个空格，不要为了对齐增加空格。
# *函数默认参数使用的赋值符左右省略空格。*
# 不要将多句语句写在同一行，尽管使用‘；’允许。
# *if/for/while语句中，即使执行语句只有一句，也必须另起一行。*

== 四 注释 ==
# 注释必须使用英文，最好是完整的句子，首字母大写，句后要有结束符，结束符后跟两个空格，开始下一句。如果是短语，可以省略结束符。
# 块注释，在一段代码前增加的注释。在‘#’后加一空格。段落之间以只有‘#’的行间隔。比如：

== 五 文档描述 ==
# *为所有的public模块、函数、类、方法写docstrings；非public的没有必要，但是可以写注释（在def的下一行）。*
# *如果docstring要换行，参考如下例子,不换行都写在同一行就可以了。*
{{{
"""Form a complex number.

Args:
    name (str): The name to use
    state (bool): Blablabla..
    
Returns:
    int. The result
    
Raises:
    KeyError
"""
}}}
# 对于不是一目了然的代码，在行为添加注释
{{{ 
# We use a weighted dictionary search to find out where i is in
# the array.  We extrapolate position based on the largest num
# in the array and the array size and then do binary search to
# get the exact number.

if i & (i-1) == 0:        # true iff i is a power of 2

}}}
# 类中如果有公共属性，要加"Attributes:" 描述
# TODO(kl@gmail.com): Drop the use of "has_key".
  TODO(Zeke) change this to use relations.
 
== 六 命名规范 ==
        总体原则，新编代码必须按下面命名风格进行，现有库的编码尽量保持风格。
# 不要单独使用小写字母‘l’，大写字母‘O’等容易混淆的字母。
# 模块命名尽量短小，使用全部小写的方式，可以使用下划线。
# 包命名尽量短小，使用全部小写的方式，不可以使用下划线。
# 类的命名使用CapWords的方式，模块内部使用的类采用_CapWords的方式。
# 异常命名使用CapWords+Error后缀的方式。
# 全局变量尽量只在模块内有效，类似C语言中的static。实现方法有两种，一是__all__机制;二是前缀一个下划线。
# 函数命名使用全部小写的方式，可以使用下划线。
# 常量命名使用全部大写的方式，可以使用下划线。
# 类的属性（方法和变量）命名使用全部小写的方式，可以使用下划线。
# 类的属性有3种作用域public、non-public和subclass API，可以理解成C++中的public、private、protected，non-public属性前，前缀一条下划线。
# 类的属性若与关键字名字冲突，后缀一下划线，尽量不要使用缩略等其他方式。
# 为避免与子类属性命名冲突，在类的一些属性前，前缀两条下划线。比如：类Foo中声明__a,访问时，只能通过Foo._Foo__a，避免歧义。如果子类也叫Foo，那就无能为力了。
# 类的方法第一个参数必须是self，而静态方法第一个参数必须是cls。
# c和c++扩展模块名以下滑线开头比如_socket
== 七 编码建议 ==
# 编码中考虑到其他python实现的效率等问题，比如运算符‘+’在CPython（Python）中效率很高，都是Jython中却非常低，所以应该采用.join()的方式。
# 尽可能使用‘is’‘is not’取代‘==’，比如if x is not None 要优于if x。
# 使用startswith() and endswith()代替切片进行序列前缀或后缀的检查。比如：
{{{
Yes:  if foo.startswith('bar'):
No:  if foo[:3] == 'bar':
}}}
# 使用isinstance()比较对象的类型。比如
{{{
Yes:  if isinstance(obj, int):
No:  if type(obj) is type(1):
}}}
# 判断序列空或不空，有如下规则
{{{ 
Yes:  if not seq:
      if seq:
No:  if len(seq)
     if not len(seq)
}}}
# 字符串不要以空格收尾。
# 二进制数据判断使用 if boolvalue的方式。
# 在Python中, 对于琐碎又不太重要的访问函数, 你应该直接使用公有变量来取代它们, 这样可以避免额外的函数调用开销. 
  当添加更多功能时, 你可以用属性(property)来保持语法的一致性.
# 如果使用property, 内部不要有计算量大的代码，因为它容易使使用者误。认为计算量很小。
# 使用基于类的异常，每个模块或包都有自己的异常类，此异常类继承自Exception。
# 异常中不要使用裸露的except，except后跟具体的exceptions。
# 异常中try的代码尽可能少。比如：
{{{class="brush: python" 
try:
    value = collection[key]
except KeyError:
    return key_not_found(key)
else:
    return handle_value(value)
要优于
try:
# Too broad!
    return handle_value(collection[key])
except KeyError:
# Will also catch KeyError raised by handle_value()
    return key_not_found(key)
}}}
# 对齐风格
{{{class="brush: python" 
# Aligned with opening delimiter
foo = long_function_name(var_one, var_two,
                         var_three, var_four)

# More indentation included to distinguish this from the rest.
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)


my_list = [
    1, 2, 3,
    4, 5, 6,
 ]
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
 )
 }}}
# 在Python中, pychecker, pydoc以及单元测试要求模块必须是可导入的. 
  你的代码应该在执行主程序前总是检查 if __name__ == '__main__' , 这样当模块被导入时主程序就不会被执行
# Always use a def statement instead of an assignment statement that binds a lambda expression directly to a name.
  Yes: `def f(x): return 2*x`    No: `f = lambda x: 2*x`
# When raising an exception in Python 2, use raise ValueError('message') instead of the older form raise ValueError, 'message'.
# When implementing ordering operations with rich comparisons, it is best to implement all six operations 
  (__eq__, __ne__, __lt__, __le__, __gt__, __ge__) rather than relying on other code to only exercise a particular comparison.
  To minimize the effort involved, the functools.total_ordering() decorator provides a tool to generate missing comparison methods.
# When a resource is local to a particular section of code, use a with statement to ensure it is cleaned up promptly and 
  reliably after use. A try/finally statement is also acceptable.
# When checking if an object is a string, keep in mind that it might be a unicode string too! In Python 2, str and unicode have a 
  common base class, basestring, so you can do:
  `if isinstance(obj, basestring):`
  Note that in Python 3, unicode and basestring no longer exist (there is only str) and a bytes object is no longer a 
  kind of string (it is a sequence of integers instead)
# Don't write string literals that rely on significant trailing whitespace. Such
  trailing whitespace is visually indistinguishable and some editors (or more
  recently, reindent.py) will trim them.
# If operators with different priorities are used, consider adding whitespace around the operators with the lowest priority(ies).
  Use your own judgment; however, never use more than one space, and always have the same amount of whitespace on both sides of a binary operator.
{{{class="brush: python" 
Yes:
i = i + 1
submitted += 1
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)
No:

i=i+1
submitted +=1
x = x * 2 - 1
hypot2 = x * x + y * y
c = (a + b) * (a - b)
 }}}
  
== Reference ==  
{{{
http://www.douban.com/note/134971609/
http://www.python.org/dev/peps/pep-0008/
}}}
